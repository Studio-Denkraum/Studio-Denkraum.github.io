{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#hello-and-to-studio-denkraums-wiki","title":"Hello and to Studio Denkraum's Wiki! \ud83c\udfae\u2728\ud83d\udc4b","text":"<p>We're thrilled to have you here! Welcome to the official wiki for Studio Denkraum, a passionate and creative indie game development team. This wiki is primarily for our internal development, but we hope it offers a glimpse into the heart and soul of our studio.</p>"},{"location":"#who-we-are","title":"Who We Are \ud83e\uddd1\u200d\ud83d\udcbb\ud83c\udfa8\ud83c\udfae","text":"<p>Studio Denkraum is a small, dedicated group of game developers, artists, and storytellers. We believe in the magic of games and the power they have to transport players to new worlds, spark imagination, and tell unforgettable stories. Our team is fueled by creativity, collaboration, and a shared love for all things gaming.</p>"},{"location":"#our-mission","title":"Our Mission \ud83d\ude80","text":"<p>Our mission is to create immersive and innovative games that resonate with players on an emotional level. We strive to push the boundaries of indie game development and bring unique experiences to life.</p>"},{"location":"#join-us-on-github","title":"Join Us on GitHub! \ud83d\udee0\ufe0f","text":"<p>For more insights into our projects, development process, and to contribute, check out our GitHub page:</p> <p>Studio Denkraum on GitHub</p> <p>Thank you for being part of our journey. Let's create something amazing together! \ud83c\udf1f</p> <p>Happy Developing! \ud83d\udcbb\u2728</p> <p>Studio Denkraum Team</p>"},{"location":"Coding/Enums/","title":"Enums","text":""},{"location":"Coding/Enums/#making-enums-global","title":"Making Enums global","text":"<p>Often, we need to use the same enum multiple times across scenes and scripts. We do not want to have to define it multiple times as we would need to update it everywhere every time and that would be extremly prone to errors.</p>"},{"location":"Coding/Enums/#implementation","title":"Implementation","text":"<p>The created script \"enum.gd\" contains all enums used throughout the game. In project settings, the script is set as a global to be autoloaded. </p> <p>https://docs.godotengine.org/en/stable/tutorials/scripting/singletons_autoload.html</p> <p></p> <p>The scripts used by the Beehave plugin are also autoloaded by the godot engine before any other scene and node.</p> <p>When referencing the enum in scripts, first the script <code>Enum</code> must be referenced:</p> <p></p>"},{"location":"Coding/Enums/#bitshifting-the-enum-value","title":"Bitshifting the enum value","text":"<p>Instead of either not assigning an integer value to the Enum or asigning it the numbers 1, 2, ..., we use the bitshift operator LEFTSHIFT <code>&lt;&lt;</code> like this:</p> <pre><code>enum Condition {\n  INVULNERABLE = 1 &lt;&lt; 0, \n  BURNING = 1 &lt;&lt; 1,\n  SLOWED = 1 &lt;&lt; 2,\n  ...\n}\n</code></pre>"},{"location":"Coding/Enums/#why-do-we-do-this","title":"Why do we do this?","text":"<p>There are a few benefits from doing this:</p> <ul> <li>Performance Optimization: Might or might not be applicable in our context, but we do not loose anything by doing it and only win if we optimize the game flow </li> <li>Fun things we can do: We can assigning multiple enum values to one attribute, which is much more performant compared to using arrays or dictionaries.</li> </ul>"},{"location":"Coding/Enums/#would-bit-shifting-be-useful-in-game-development","title":"Would bit shifting be useful in game development?","text":"<p>Bit shifting can be very useful in game development, especially for tasks that require performance optimization. It's often used in graphics programming, for manipulating pixel data, or in systems where memory and processing efficiency are critical. Bit shifting allows developers to perform operations quickly, which is essential for maintaining high frame rates in games. (https://www.lenovo.com/us/en/glossary/bit-shift/?orgRef=https%253A%252F%252Fwww.google.com%252F)</p>"},{"location":"Coding/Enums/#example","title":"Example","text":"<p>An entity (Player/Enemy/...) can have multiple active conditions, which affect its stats etc. Before, I would have implemented this by using either (A) an Dictionary with all possible conditions and assign a boolean to it or (B) an Array containing all active conditions. In both cases, it would entail a lot of performance looking through the Dictionary or Array to find the right value.</p> <p>Instead, we create an attribute <code>condition</code> of type Enum.Condition and can assign new conditions, remove conditions and check for specific conditions using bitwise operators <code>|</code>, <code>^</code> and <code>&amp;</code>:</p> <p>We assign new values using <code>|</code> (bitwise OR) <pre><code>var current_condition = Enum.Condition.SLOWED       # = 00000100\ncurrent_condition |= Enum.Condition.BURNING         # 00000100 | 00000010 = 00000110\n</code></pre></p> <p>We remove values using <code>^</code> (bitwise XOR) <pre><code>current_condition ^= Enum.Condition.BURNING         # 00000110 ^ 00000010 = 00000110\n</code></pre></p> <p>We check for values using <code>&amp;</code> (bitwise AND) <pre><code>if current_condition &amp; Enum.Condition.SLOWED        # 00000110 &amp; 00000100 = 00000100 =&gt; true\n  print(\"Entity is slowed\")\nif current_condition &amp; Enum.Condition.INVULNERABLE  # 00000110 &amp; 00000001 = 00000000 =&gt; false\n  print(\"Entity is invulnerable\")\n</code></pre></p>"},{"location":"Coding/Enums/#sources","title":"Sources","text":"<p>What is Bitshift (IBM): https://www.ibm.com/docs/en/i/7.3?topic=expressions-bitwise-left-right-shift-operators</p> <p>Discussion regarding this in Reddit: https://www.reddit.com/r/godot/comments/hb382k/bitwise_operations_bit_flags/</p> <p>Bitshift in C++: https://stackoverflow.com/questions/18841113/c-assigning-enums-explicit-values-using-bit-shifting</p>"},{"location":"Coding/Hitbox_and_Hurtbox/","title":"Hitbox and Hurtbox","text":""},{"location":"Coding/Hitbox_and_Hurtbox/#definition","title":"Definition","text":"<p>Hit boxes are areas where an attack will hit and do damage.  Hurt boxes are areas where a player or bot can be hurt by another's attack.</p>"},{"location":"Coding/Hitbox_and_Hurtbox/#how-to-use","title":"How to Use","text":""},{"location":"Coding/Hitbox_and_Hurtbox/#hitbox","title":"Hitbox","text":"<ol> <li>Add the node \"HitBox\" to the scene</li> <li>Add a \"CollisionShape3D\" as a child of the HitBox node</li> <li>Add a \"Shape\" in the inspector of CollisionShape3D and adjust it in the viewport</li> <li>If not already present, add a \"AnimationPlayer\" and create an animation.</li> <li> Now you need to create a keyframe for the \"disabled\" property of the CollisionShape3D. For that press that button: (Image_1)</li> <li> Create a keyframe (right-click in the timeline) at the end of the animation and enable it (Image_2).    Select the \"RESET\" Animation and set \"disabled\" property to \"true\" (Image_3).      This ensures that the Hitbox is only active during the attack-animation.       </li> <li>Ensure you have a \"damage\" variable in the Hitbox-script</li> </ol> <p>Image_1:</p> <p></p> <p>Image_2:</p> <p></p> <p>Image_3:</p> <p></p>"},{"location":"Coding/Hitbox_and_Hurtbox/#hurtbox","title":"Hurtbox","text":"<ol> <li>Add the node \"HurtBox\" to the scene</li> <li>Add a \"CollisionShape3D\" as a child of the HurtBox node</li> <li>Add a \"Shape\" in the inspector of CollisionShape3D and adjust it in the viewport</li> <li>make sure the root node has a script with the method \"take_damage(amount)\"</li> </ol>"},{"location":"Coding/Hitbox_and_Hurtbox/#code-implementation","title":"Code Implementation","text":"<pre><code>class_name HitBox\nextends Area3D\n\n@export var damage = 1\n\nfunc _init():\n    collision_layer = 2\n    collision_mask = 0\n</code></pre> <pre><code>class_name HurtBox\nextends Area3D\n\nfunc _init():\n    collision_layer = 0\n    collision_mask = 2\n\n\nfunc _ready():\n    #signal to detect hitbox\n    connect(\"area_entered\", self._on_area_entered)\n\nfunc _on_area_entered(hitbox: HitBox):\n    if hitbox == null:\n        return\n\n    if owner.has_method(\"take_damage\"):\n        owner.take_damage(hitbox.damage)\n</code></pre> <p>The \"class_name\" keyword can be used to add the script to the global scope and make it accessible in the node selection </p> <p>Hit- and Hurtbox both extend \"Area3D\", so if you add them to the scene you need CollisionShape3D as a child node. </p> <p>The shape of the CollisionShape3D defines the effective hit or hurt area.</p>"},{"location":"Coding/Inventory/","title":"Inventory","text":""},{"location":"Coding/Abilities/Active_Ability/Basic_Structure/","title":"Basic Structure","text":""},{"location":"Coding/Abilities/Active_Ability/Basic_Structure/#where-do-i-create-a-new-ability","title":"Where do I create a new Ability","text":"<p>All abilitys are saved in the \"abilities\" folder. </p>"},{"location":"Coding/Abilities/Active_Ability/Basic_Structure/#file-naming","title":"File Naming","text":"<p>Because of the way abilities are loaded it is very important that the folder and the script have the same name.</p> <p></p>"},{"location":"Coding/Abilities/Active_Ability/Basic_Structure/#components-of-an-ability","title":"Components of an Ability","text":"<p>The minimal requirements of an ability is a node3D with the same name as the ability. Here a script controlls the fundamental executions and therefore requires a function with the name \"execute\".</p> <p>The main functionality of the ability is handeled in components which are added as childen to the root node. </p> <p></p>"},{"location":"Coding/Base_Classes/Active_Ability/","title":"Active Ability","text":""},{"location":"Coding/Base_Classes/Active_Ability/#usage","title":"Usage","text":"<p>Serves as base for the active abilities. It contains different stats depending on the ability such as \"Energy cost\", damage, etc. It is currently very barebone and should be adapted regarding the needs of the new ability system.</p>"},{"location":"Coding/Base_Classes/Entity/","title":"Entity","text":""},{"location":"Coding/Base_Classes/Entity/#usage","title":"Usage","text":"<p>The script Entity serves as a base for the player node as well as the enemy and npc nodes.  It contains basic attributes to describe the states of health, energy etc. as well as functions to modify these states.  With load_ability, abilities used by the entity can be loaded in the scene.</p> <p></p> <p>The attribute \"Resistence\" could be implemented with a dictionary as follows:</p> <pre><code>enum DAMAGE_TYPE {FIRE, ICE, ...}\n\n// Example: the player is vulnerable against Fire damage \n// and resistent against Ice damage\nvar resistance = {DAMAGE_TYPE.FIRE: -10, DAMAGE_TYPE.ICE: 10}\n</code></pre>"},{"location":"Coding/Base_Classes/Entity/#implementation","title":"Implementation","text":"<p>Attributes include basic stats like Health, Energy, Armor and movement &amp; physic specific stats:  - (current and maximal) speed / velocity: How fast does the entity move?  - acceleration: How fast does the entity get fast? (\"the rate of change of the velocity of an object\") - agility: How fast can the entity turn? (not used, instead currently angular_rotation in Player Node)</p> <p>The functions include modifying these values as well as loading abilites. This makes the modular implementation of abilities possible.</p>"},{"location":"Coding/Components/Concept/","title":"Concept","text":""},{"location":"Coding/Components/Concept/#motivation","title":"Motivation","text":"<p>Instead of implementing complex inheritance hierachies, where we would very quickly loose track of where what happens, we decided to implement functionalities as cohesive modules (-&gt; components). </p> <p>The aim is to use these almost as black boxes, to build complex abilities/enemies/npcs/etc.</p>"},{"location":"Coding/Components/Concept/#implementation","title":"Implementation","text":"<p>To build a new component, we create (1) a scene made up only of a root node of type Node. To this scene we attach (2) a script with the same node, containing all the functionality of the component.  We need a scene, so that we can use the component as module in other scenes, by simply drag-and-dropping them into the scene. </p>"},{"location":"Coding/Components/Concept/#file-structure","title":"File Structure","text":"<p>The components are stored in a /component folder under /game. For each component, we create a new folder with the components name containing the same named scene and connected script.</p>"},{"location":"Coding/Components/Concept/#properties","title":"Properties","text":"<p>With the @export keyword, we can make properties used by the component appear in the editor. This way, we can write our component in a way,  that the user of the component only needs to set the appropriate properties in order to use it. That way, the person does not have to take a look at the components code itself (-&gt; black box).</p>"},{"location":"Coding/Components/Concept/#example","title":"Example","text":"<p>In the file structure</p> <p></p> <p>The component scene</p> <p></p> <p>Used in a scene</p> <p></p> <p>Using ##, we can add descriptions to the exported properties as well as the component itself, making it even more self-explanatory.</p> <p>Component's properties in Editor</p> <p></p>"},{"location":"Coding/Components/Hitbox_%20and_HurtboxComponent/","title":"Hitbox  and HurtboxComponent","text":""},{"location":"Coding/Components/Hitbox_%20and_HurtboxComponent/#description","title":"Description","text":"<p>Entities such as the Player, NPCs, Enemies, Bossess, ... get a Hurtbox --&gt; did something hurt me?</p> <p>Abilities such as the AOE or Projectiles get a Hitbox --&gt; did I hit something? </p> <p>The HurtboxComponent works in synergy with the StatComponent. Therefore the StatComponent is necessary to have the full effect of the Hurtbox aka the Entity not only getting hit but also getting damage from that hit.</p>"},{"location":"Coding/Components/Hitbox_%20and_HurtboxComponent/#how-to-use","title":"How to Use","text":"<p>The HitboxComponent and HurtboxComponent only fully work, when both are implemented.</p>"},{"location":"Coding/Components/Hitbox_%20and_HurtboxComponent/#hitboxcomponent","title":"HitboxComponent","text":"<p>Usage in ProjectileComponent:</p> <p> </p> <ul> <li>ParentNode: The root node of the Scene --&gt; ProjectileComponent. Used instead of get_parent() to secure that the component will work in future e.g. even if nodes are added to group components.</li> <li>Hitbox: The actual Hurtbox (CollisionShape3D) representing the area where the entity hurts. Must be child of the HitboxComponent to connect to its signals.</li> </ul>"},{"location":"Coding/Components/Hitbox_%20and_HurtboxComponent/#hurtboxcomponent","title":"HurtboxComponent","text":"<p>Usage in Ramona (NPC):</p> <p> </p> <ul> <li>StatComponent: handling the changes to Health (and other effects regarding the Players stats)</li> <li>ParentNode: The root node of the Scene --&gt; Ramona.</li> <li>Hurtbox: The actual Hurtbox (CollisionShape3D) representing where the entity can be hurt. Must be child of the HurtboxComponent to connect to its signals.</li> </ul>"},{"location":"Coding/Components/Hitbox_%20and_HurtboxComponent/#implementation","title":"Implementation","text":"<p>The two components communicate with each other using signals.</p> <p></p> <p>The reason for this is, that the hitbox and hurtbox do not know the stats of the entities involved  (in this example the health of the Player and the damage of the Ability).</p> <ul> <li>The HitboxComponents communicates that it collided with a Hurtbox to the Ability --&gt; i_hit_something(hurtbox).  The HitboxComponents connects to the _on_area_entered()-signal of its child (the Hitbox) to detect collision.</li> </ul> <pre><code># HitboxComponent.gd\nextends Area3D\nclass_name Hitbox\n\n@export var parent_node: Node3D\n@export var hitbox: CollisionShape3D\n\nsignal i_hit_something(hurtbox)\n\nfunc _on_area_entered(area3D: Area3D) -&gt; void:\n    if area3D is Hurtbox:\n        i_hit_something.emit(area3D)\n</code></pre> <ul> <li>The Ability knows its stat and sends the Hurtbox a signal containing the received damage --&gt; get_damage(damage).</li> </ul> <pre><code># ProjectileComponent.gd\nextends RigidBody3D\n\n...\n\nfunc _on_hitbox_component_i_hit_something(hurtbox: Hurtbox) -&gt; void:\n    hurtbox.take_damage(ability_resources.damage, ability_resources.damagetype)\n</code></pre> <ul> <li>The Hurtbox itself does not change anything about the Player aka its health.   Instead it relays the damage to the StatComponent, where the damage is actually taken.</li> </ul> <pre><code># HurtboxComponent.gd\nextends Area3D\nclass_name Hurtbox\n\n@export var stat_component: Node\n@export var parent_node: Node3D\n@export var hurtbox: CollisionShape3D\n\nfunc take_damage(damage: int, damage_type: Enum.DamageType) -&gt; void:\n    if (stat_component):\n        stat_component.take_damage(damage, damage_type)\n</code></pre>"},{"location":"Coding/Components/InteractionComponent/","title":"InteractionComponent","text":""},{"location":"Coding/Components/InteractionComponent/#functionality","title":"Functionality","text":"<p>Recognizing the start and end of an interaction, when the player steps into or out of the specified area and make the implementing node turn to player and turn back, after ending the interaction.</p>"},{"location":"Coding/Components/InteractionComponent/#implementation","title":"Implementation","text":""},{"location":"Coding/Components/InteractionComponent/#properties","title":"Properties","text":"<p>interaction_area: Area3D --&gt; Area where the interaction is trigger</p> <p>parent_node: Node3D --&gt; Root node of implementing node, that will be rotated</p> <p>label: Label3D --&gt; Label, visible when player is within interaction_area</p> <p>follow_player: bool --&gt; If true, the implementing node continues to rotate to look at player, while they are in the area. Otherwise, it only rotates once when the player enters the area.</p>"},{"location":"Coding/Components/InteractionComponent/#set-up","title":"Set up","text":"<p>After checking if all properties were set, we connect to the signals of the interaction_area:</p> <pre><code>interaction_area.body_entered.connect(_on_interaction_area_body_entered)\ninteraction_area.body_exited.connect(_on_interaction_area_body_exited)\n</code></pre> <p>Additionally, we set up a timer with a wait time of 1 second. The implementing node will wait that time, before turning back to its original position after the player exited the area. </p> <pre><code># create timer\nturn_back_timer = Timer.new()\nturn_back_timer.wait_time = 1\n# connect timer signal\nturn_back_timer.timeout.connect(_on_turn_back_timer_timeout)\nadd_child(turn_back_timer)\n</code></pre>"},{"location":"Coding/Components/InteractionComponent/#rotation","title":"Rotation","text":"<p>When the implementing node is set up, the current rotation (&amp; scale) is saved into \"original_basis\". When the player is detected in the area, the \"target_basis\" is set to looking at the player (see below). </p> <p><pre><code>func rotateToPlayer() -&gt; void:\n    # normalized vector pointing from this to player\n    player_vector = parent_node.global_position.direction_to(player.position)\n    # get rotation and scale of player\n    player_basis = Basis.looking_at(player_vector)\n    target_basis = player_basis\n</code></pre> After exiting the area, a timer is started and after its timeout, the \"target_basis\" is set to the \"original_basis\" prompting the node to turn back to its original rotation. </p> <p>The rotation itself is implemented using Basis.slerp, to change the rotation every delta by a defined \"weight\" to the target (see below, line 7). As we only want the node to turn around the y axis to not have a leaning node, we have to reset the Z and X rotation to 0 (line 9 and 10)</p> <pre><code>func _process(_delta: float) -&gt; void:\n    if (target_basis):\n        if is_in_interaction_area &amp;&amp; follow_player:\n            rotateToPlayer()\n        # slowly turn either to face player entity or \n        # (if they exited the interaction area) back to its original position\n        parent_node.basis = parent_node.basis.slerp(target_basis, 0.05)\n        # reset z and x rotation, to only turn around y axis \n        parent_node.rotation.z = 0\n        parent_node.rotation.x = 0\n</code></pre> <p>When \"follow_player\" is set as true, the \"target_base\" is updated every delta to represent the players position (see above, line 3 and 4). </p>"},{"location":"Coding/Components/MovementComponent/","title":"MovementComponent","text":""},{"location":"Coding/Components/MovementComponent/#movement-component","title":"Movement Component","text":"<p>This component will move the parentNode3D towards the Player if the Player enters an InteractionArea3D. This code moves the parent_node towards the player.global_transform.origin. <pre><code>var target_pos = player.global_transform.origin\n    nav_agent.target_position = target_pos\n    var current_location = parent_node.global_transform.origin\n    var next_location = nav_agent.get_next_path_position()\n    var new_velocity = (next_location - current_location).normalized() * speed\n    parent_node.velocity = new_velocity\n    parent_node.move_and_slide()\n</code></pre> This code detects every Node3D and checks if its part of the Group \"Player\" and if true, assigns this body to the variable \"player\". This can be extended for all other Groups.  <pre><code>func _on_interaction_area_3d_body_entered(body: Node3D) -&gt; void:\n    for group in body.get_groups():\n        match group:\n            \"Player\":\n                player = body\n        # if more needed just add here\n</code></pre></p>"},{"location":"Coding/Components/StatComponent/","title":"StatComponent","text":""},{"location":"Coding/Components/StatComponent/#functionality","title":"Functionality","text":"<p>Handle changes to the base stats of an entity (Player, Enemy, NPC)</p>"},{"location":"Coding/Components/StatComponent/#implementation","title":"Implementation","text":""},{"location":"Coding/Components/StatComponent/#properties","title":"Properties","text":"<p>stat: StatResource \u2192 Resource with the entities stats (data/stat/stat_resource.gd)</p>"},{"location":"Coding/Components/StatComponent/#stat-changes","title":"Stat Changes","text":"<p>Health and Energy can be instantiously be changed e.g. by using Energy for abilities or getting hit:</p> <ul> <li><code>func take_damage(damage: int, damage_type: Enum.DamageType)</code></li> <li><code>func use_energy(amount: int)</code></li> <li><code>func heal(amount: int)</code></li> </ul> <p>When the entity receives damage, the damage is first filtered through the entity's resistances and the result is then applied -&gt; <code>func _filter_through_resistance(damage: int, damage_type: Enum.DamageType)</code></p>"},{"location":"Coding/Components/StatComponent/#effects","title":"Effects","text":"<p>Additionally, effects can be applied: Instead of once, stat changes are applied every tick over a set duration (or indefinitely, if set as such). An example would be a damage-over-time burning effect after getting hit by a fire ability. </p> <p>A Tick in this case refers to our own defined one-second interval, in which effects are applied and the stats are updated.</p> <p>Effects are stored in the EffectQueue and applied every tick. Effects are Resources definied by the Script EffectResource and stored under data/effect/resources. </p> <pre><code># data/effect/effect_resource.gd\nextends Resource\nclass_name EffectResource\n\n## Unique identifier\n@export var uid: int\n## Name of the effect\n@export var name := ''\n## Icon for the status preview\n@export var icon: Texture2D\n## Associated condition. Is added at the beginning of the effect and removed at the end.\n@export var condition: Enum.Condition\n## Duration of effect in ticks.\n## [br][code]0.0[/code] is interpreted as the effect being instantanous and only applied once.\n@export var duration := 0.0\n## Impact is going on indefinite\n@export var indefinite := false\n## How is the value applied to the base stat.\n@export var procedure: Enum.StatProcedure\n## Stat of the entity that is affected.\n@export var stat: Enum.Stat\n## Value to apply to base stat (every tick).\n@export var value := 0.0\n## Handling of multiple applications of the same effect.\n@export var stack_type:= Enum.ImpactStackType.NOT_STACKABLE\n</code></pre>"},{"location":"Coding/Components/StatComponent/#add_effecteffect-effectresource","title":"<code>add_effect(effect: EffectResource)</code>","text":"<p>When a new effect is added to the Queue, it is first checked, if the same effect is already applied (comparing the effect's UID). Depending on the set StackType (Enum <code>Enum.ImpactStackType</code> under global/enum.gd), the effect in the queue is modified. </p> <ul> <li>NOT_STACKABLE: Nothing is changed</li> <li>DURATION_STACKED: The duration of the effect is refreshed, when the second one is applied</li> <li>IMPACT_STACKED: The value change of the effect is applied twice as much (e.g. double burning damage)</li> <li>DURATION_AND_IMPACT_STACKED: Both the duration and the impact are stacked</li> </ul>"},{"location":"Coding/Components/StatComponent/#_apply_effects","title":"<code>_apply_effects()</code>","text":"<p>Every tick, the effects in the queue are applied:</p> <ol> <li>Check if effect has finished (AND is not indefinite) \u2192 remove effect from queue and associated condition from entity</li> <li>Effect has not finished \u2192 Using the external script global/utility.gd to apply the set effect to the stat (<code>Utility.apply_effect(effect: EffectResource, stat_resource: StatResource)</code>)</li> </ol> <p>To apply the effect, three values from the EffectResource are important:</p> <ul> <li><code>var stat: Enum.Stat</code>: which stat is impacted (health, energy, ...)</li> <li><code>var value := 0.0</code>: what value is applied in the effect?</li> <li><code>var procedure: Enum.StatProcedure</code>: how is the value applied?</li> </ul> <pre><code># global/enum.gd\nenum StatProcedure {\n    NONE = 0 &lt;&lt; 0,\n    ADD = 1 &lt;&lt; 0, # add the value to base stat\n    MULTIPLY = 1 &lt;&lt; 1, # multiply base stat by this value\n    ADD_PERCENTAGE = 1 &lt;&lt; 2, # add the value as percentage of the base stat\n}\n</code></pre>"},{"location":"Coding/Components/StatComponent/#communication-with-statuicomponent","title":"Communication with StatUIComponent","text":"<p>To keep the UI updated, a signal is emitted each time the current energy and health value changes or whenever the entity dies.</p> <p></p> <pre><code># signals for environment and ui\nsignal died\nsignal health_changed(new_value)\nsignal energy_changed(new_value)\n</code></pre> <p>Additionally, the getters for these values are created to be used by the StatUIComponent.</p> <pre><code>func get_max_health() -&gt; int:\n    return stat.health_max\n\nfunc get_max_energy() -&gt; int:\n    return stat.energy_max\n\nfunc get_current_health() -&gt; int:\n    return stat.health_current\n\nfunc get_current_energy() -&gt; int:\n    return stat.energy_current\n\nfunc get_temp_health() -&gt; int:\n    return stat.health_temp\n</code></pre>"},{"location":"Game_Design/Ideas_Mechanics/","title":"Ideas Mechanics","text":""},{"location":"Game_Design/Ideas_Mechanics/#stand-mai-2024","title":"Stand: Mai 2024","text":"<ul> <li>Ausr\u00fcstung bestimmt die Resistenzen und Anzahl der Slots</li> <li>Ausr\u00fcstung und F\u00e4higkeiten haben verschiedene Stufen (k\u00f6nnen durch Crafting verbessert/ver\u00e4ndert werden)</li> <li>Jedes Ausr\u00fcstungsteil hat ein Aktiven und Passive Slots, je nach Slot werden die Aktiven oder Passiven teile der Skills verwendet</li> <li>Ausr\u00fcstung wird duch Gegener gedroppt F\u00e4higkeiten maybe aus Kisten oder nach Bossen</li> <li>Setbonus?! Traits wie uin tft?!</li> <li>Player Character kann sich tags\u00fcber aufladen (Energie-Bar)</li> </ul>"},{"location":"Game_Design/Level_Design/","title":"Level Design","text":""},{"location":"Game_Design/Level_Design/#inspo","title":"Inspo","text":"<p>Zum Thema Design der \"Level\"/R\u00e4ume/Biome Map -&gt; finde es sehr cool, dass es bei Celeste Chapter gibt, in denen sich der Mood visuell und von der Musik her stark unterscheidet</p>"},{"location":"Game_Design/Level_Design/#level-design-ideen","title":"Level Design Ideen","text":"<ul> <li>Verlassende Gleise / Bahnstation (komplett \u00dcberwuchert, vereinzelnt Z\u00fcge / Abteile)</li> </ul>"},{"location":"Game_Design/Level_Design/#3d-backgroundtilemap","title":"3D Background/Tilemap","text":"<p>Nach kurzer Recherche hab ich herausgefunden, dass man in Godot GripMaps (https://docs.godotengine.org/en/stable/tutorials/3d/using_gridmaps.html) benutzen kann.</p> <p>\"Enter the gungeon\" benutzt dasselbe Prinzip, um einen 2.5D look zu generieren: </p> <p>Mehr Insight dazu: https://www.youtube.com/watch?v=XK5qpEmUA6w Wichtig ist Orthogonal Camera!</p> <p>Texturen austauschen f\u00fcr Gridmap MeshLibrary: https://www.reddit.com/r/godot/comments/y1c913/problem_with_glb_meshes/ Tldr: Changing Textures on a MeshLibrary/Gridmap is not doable. Probably have to create a new MeshLibrary and place Tiles again?</p>"},{"location":"Game_Design/Moodboard/","title":"Moodboard","text":""},{"location":"Game_Design/Moodboard/#inspiration","title":"Inspiration","text":"<ul> <li>Path of Exile</li> <li>Deadcells</li> <li>Risk of Rain 2</li> <li>Hades</li> <li>(TFT, Transistor, etc)</li> </ul>"},{"location":"Game_Design/Moodboard/#environment-design","title":"Environment Design","text":""},{"location":"Game_Design/Moodboard/#character-design","title":"Character Design","text":""},{"location":"Game_Design/Ability_System/Ability_System/","title":"Ability System","text":""},{"location":"Game_Design/Ability_System/Ability_System/#concept","title":"Concept","text":"<p>2 active abilities slots 0-n passive slots 1 movement-skill slot  </p> <ul> <li>active abilites are NOT on equipment (the idea was that ability1 can be assigned to the \u201cright\u201d arm/hand and ability2 to the \u201cleft\u201d arm/hand)</li> <li>each equipment can have passive slots (on torso maybe more slots than on head equipment)</li> <li>each passive slot is assigned to either ability1 or ability2 and influences these</li> <li>Movement Abilities have no passives \u201cfor now\u201d (because you would have to implement special passives)</li> </ul>"},{"location":"Game_Design/Ability_System/Ability_System/#file-structure","title":"File Structure","text":"<pre><code>res://scenes/game  \n    abilities  \n        active_abilities  \n            ability1  \n                ability1.gd (inherits from active_ability.gd)  \n                ability1.tscn (scene with ability1.gd script and ability1 \"model\"  \n            ability2  \n                ability2.gd  \n                ability2.tscn  \n            active_ability.gd (Basis class)  \n        passive_abilities  \n\n            passive_ability.gd (Basis class)  \n    ability_ui  \n        active_abilities  \n            ability1  \n                ability1.tres (Resource of ability.gd with own name)  \n            ability2  \n                ability2.tres  \n        passive_abilities  \n\n        ability_inventory.tscn (scene with ability-UI)\n        ability_inventory.tres (Stores arrays of selected active abilities and passives)\n        ability_inventory.gd (inherits from resource, own class_name, defines arrays)\n        ability.gd (inherits from resource, own class_name, has variable \u201cname: String\u201d)\n        + further UI-Nodes\n</code></pre>"},{"location":"Game_Design/Ability_System/Ability_System/#relation-of-ability-system-and-ui","title":"Relation of Ability System and UI","text":"<p>Player-script looks at which abilities are added to the ability_inventory (are contained in ability_inventory.tres).  The name of each ability is taken and loaded. the ability_inventory.tscn node is instantiated as a child instance</p>"},{"location":"Game_Design/Characters/Enemies/","title":"Enemies","text":""},{"location":"Game_Design/Characters/Enemies/#enemy","title":"Enemy","text":"<p>Enemy is created with components.  They use the MovementComponent with an InteractionArea3D. The enemy is walking towards the Player, if it enters the InteractionArea (detected by the corresponding group).  If the Player leaves the InteractionArea the enemy stops moving. </p>"},{"location":"Game_Design/Characters/Enemies/#requirements","title":"Requirements","text":"<ul> <li>all of the Environment of the Game needs to be a child of NavigationRegion3D</li> <li>Enemy needs a NavigationAgent3D</li> <li>Enemy needs InteractionArea3D </li> </ul>"},{"location":"Game_Design/Characters/NPC/","title":"NPC","text":""},{"location":"Game_Design/Characters/NPC/#non-playable-characters","title":"Non-Playable-Characters","text":"<p>NPCs can be found through out the game. Some NPCs should be taken back to the homebase and give different bonuses to the player. </p>"},{"location":"Game_Design/Characters/NPC/#blacksmith-ramona","title":"Blacksmith (Ramona)","text":"<p>At save stages between rooms. Smith lets MC craft and upgrade its gear and abilities.</p>"},{"location":"Game_Design/Characters/NPC/#pet-trader-dirk","title":"Pet-Trader (Dirk)","text":"<p>Trades with pets </p>"},{"location":"Game_Design/Characters/NPC/#pets","title":"Pets","text":"<p>Pets help the MC in the run with different buffs. - Bigger Inventory - collects Items  - fires one Ability  - etc.</p>"},{"location":"Game_Design/Characters/NPC/#stat-skilltree","title":"Stat-/Skilltree","text":"<p>(maybe AI in Homebase) MC has a carry-over progression in the form of a Stat-/Skilltree, this NPC opens up this tree and lets the MC change and progress. </p>"},{"location":"Game_Design/User_Interface/Inventory_UI/","title":"Game-UI","text":"<ol> <li>Inventory</li> <li>Armor-Slots</li> <li>Ability Slots (2 Actives, n Passives)</li> </ol> <p>All 3 UI elements are instantiated to the player as child nodes, for ez access to the objects selected in the UI</p> <p></p>"},{"location":"Orga/Git/","title":"Git","text":""},{"location":"Orga/Git/#branches","title":"Branches","text":"Branch Beschreibung dev Darauf wird entwickelt und die Feature/Fix-Branches per Pull Request gepushed main Beinhaltet einen stabilen Stand des Projekts, darauf wird ein Pull Request nach gemeinsamer Absprache gemacht"},{"location":"Orga/Git/#workflow","title":"Workflow","text":"<p>Vom Develop-Branch abstammend einen neuen Branch f\u00fcr Feature / Bugfix erstellen. Auf diesem wird gearbeitet und die Arbeit regelm\u00e4\u00dfig gepushed, bis es fertig ist. Im Anschluss wird ein Pull Request erstellt, um die \u00c4nderungen auf dem tempor\u00e4ren Branch in Develop zu mergen. Pull Requests k\u00f6nnen mit GitHub Desktop oder auch direkt auf GitHub.com erstellt werden. Letzteres hat den Vorteil, dass immer mit der aktuellen Version von \"dev\" gemerged wird. Sonst muss man sichergehen, dass man die aktuellste Version bei sich lokal hat.</p> <p>Empfohlender Weg \u00fcber GitHub.com </p> <p>Im Pull Request bietet es sich an, eine kurze Beschreibung hinzuzuf\u00fcgen, die die \u00c4nderungen zusammenfasst. Gegebenfalls k\u00f6nnen Dokumente und Bilder angeh\u00e4ngt werden. Nach dem Erstellen des Pull Requests auf develop, kann dieser direkt angenommen werden. Es wird kein Approval ben\u00f6tigt. </p>"},{"location":"Orga/Git/#neuer-remote","title":"Neuer Remote","text":"<p>Wegen des Repo-Umzugs in die Organisation, muss der Remote bei jeder Person, die bereits mit dem Repo arbeitet, einmalig angepasst werden:</p> <p>Aktuellen Remote anzeigen: <pre><code>$ git remote -v\norigin  git@github.com:Androx765/Game_dev.git (fetch)\norigin  git@github.com:Androx765/Game_dev.git (push)\n</code></pre> Neuen URL als Remote setzen:  <pre><code>git remote set-url origin git@github.com:Studio-Denkraum/game-dev.git\n</code></pre> Pr\u00fcfen, ob es geklappt hat: <pre><code>$ git remote -v\norigin  git@github.com:Studio-Denkraum/game-dev.git (fetch)\norigin  git@github.com:Studio-Denkraum/game-dev.git (push)\n</code></pre></p>"},{"location":"Orga/Git/#namenskonvention","title":"Namenskonvention","text":"<ul> <li>Feature-Branch: \"feature/[beschreibung]\"</li> <li>Bugfix-Branch: \"bugfix/[beschreibung]\"</li> <li>Hotfix-Branch: \"hotfix/[beschreibung]\"</li> </ul> <p>Beschreibungen und Branch-Namen generell in kebab-case: kleingeschrieben und Worte mit Bindestrich verbunden -&gt; Zum Beispiel \"feature/enemy-movement\"</p> <p>Quelle: https://dev.to/couchcamote/git-branching-name-convention-cch</p>"},{"location":"Orga/Godot/","title":"Godot","text":""},{"location":"Orga/Godot/#namenskonvention","title":"Namenskonvention","text":"<ul> <li>Ordner-, File-, script-, scene-namen: snake_case</li> <li>Nodes: PascalCase</li> <li>brachnes: kebab-case </li> </ul>"}]}